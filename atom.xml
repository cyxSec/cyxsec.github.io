<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>maoblog</subtitle>
  <link href="https://cyxsec.github.io/atom.xml" rel="self"/>
  
  <link href="https://cyxsec.github.io/"/>
  <updated>2024-05-27T02:33:29.498Z</updated>
  <id>https://cyxsec.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux渗透研究--Linux特性利用和极限场景处理</title>
    <link href="https://cyxsec.github.io/2024/04/Linux%E5%90%8E%E6%B8%97%E9%80%8F%E7%A0%94%E7%A9%B6--Linux%E7%89%B9%E6%80%A7%E5%88%A9%E7%94%A8%E5%92%8C%E6%9E%81%E9%99%90%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86/"/>
    <id>https://cyxsec.github.io/2024/04/Linux%E5%90%8E%E6%B8%97%E9%80%8F%E7%A0%94%E7%A9%B6--Linux%E7%89%B9%E6%80%A7%E5%88%A9%E7%94%A8%E5%92%8C%E6%9E%81%E9%99%90%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86/</id>
    <published>2024-04-29T03:28:25.000Z</published>
    <updated>2024-05-27T02:33:29.498Z</updated>
    
    <content type="html"><![CDATA[<p>Linux渗透的时候要理解和接受一个概念：Linux一切皆文件</p><p><strong>简单记录一下渗透中利用的Linux特性、后渗透的极限场景处理</strong></p><p>Linux不同发行版有他们自己的特性，这些特性在渗透和后渗透中都可以用到</p><h2 id="查看系统ip信息"><a class="markdownIt-Anchor" href="#查看系统ip信息"></a> 查看系统ip信息</h2><ul><li>阉割 ip a、ifconfig</li></ul><p>在<strong>非DHCP</strong>情况下，不同发行版在本地文件可以找到ip配置信息</p><p>RHEL/CentOS系</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-&lt;interface&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:%5CUsers%5C14198%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240429114106822.png" alt="image-20240429114106822" /></p><p>Debian系</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;network&#x2F;interfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他：</p><ul><li>查看arp表</li><li>hostname -I</li><li>端口连接信息</li></ul><h2 id="查看端口连接信息"><a class="markdownIt-Anchor" href="#查看端口连接信息"></a> 查看端口连接信息</h2><p>/proc/net 下面的tcp和udp文件会存储网络端口连接情况</p><p><img src="C:%5CUsers%5C14198%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240527102511919.png" alt="image-20240527102511919" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux渗透的时候要理解和接受一个概念：Linux一切皆文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单记录一下渗透中利用的Linux特性、后渗透的极限场景处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux不同发行版有他们自己的特性，这些特性在渗透和后渗透中都可以用到&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://cyxsec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>端口复用技术</title>
    <link href="https://cyxsec.github.io/2022/08/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <id>https://cyxsec.github.io/2022/08/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/</id>
    <published>2022-08-03T03:16:57.000Z</published>
    <updated>2024-07-15T09:53:04.565Z</updated>
    
    <content type="html"><![CDATA[<p>很多情况下遇到无法解析webshell环境（python之类的rce），或内网环境遇到强隔离，限定了通讯端口。</p><p>端口复用工作中用的不算太多，主要是考虑客户业务的稳定性，导致很多时候不太敢上端口复用。</p><p>端口复用根据不同场景有不同的实现方案，下面简单总结一下。</p><p><strong>具体的概念可以直接看这篇，讲的十分详细，在网上搜了很多篇， 感觉都是抄的这篇，写的确实好</strong>：<a href="http://mobile.51cto.com/hot-557084.html">http://mobile.51cto.com/hot-557084.html</a></p><h2 id="0x01基于端口转发协议分流的端口复用"><a class="markdownIt-Anchor" href="#0x01基于端口转发协议分流的端口复用"></a> 0x01基于端口转发+协议分流的端口复用</h2><p>配置过程大概是：</p><ul><li>使用分流工具，监听本地9999端口的流量，根据协议做分流区分，如正常的http协议依然按照正常的业务逻辑转发到80端口，其他我们指定的协议就可以转发到我们实际的利用端口，即可完成端口复用。</li></ul><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;Pandentia&#x2F;protoplex这是一个协议复用的工具，比如命令可将本地9999端口的流量根据协议类型转到本地的2333和80端口。注: 在实战环境中，先用protoplex进行分流，然后再进行重定向。.&#x2F;protoplex --socks5 192.168.154.130:2333 --http 127.0.0.1:80 -b 192.168.154.130:9999注: protoplex设置分流的http协议IP和重定向的ip不要设置为同一个ip,否则会形成闭环。同时该工具还支持其他协议的分流，如：    SSH    HTTP    TLS (&#x2F; HTTPS)    OpenVPN    SOCKS4 &#x2F; SOCKS5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>利用netsh（win）和iptables （Linux）配置端口转发策略，将请求服务器80端口的流量转发到本地的9999端口（对应监听即可）</p><pre class="line-numbers language-none"><code class="language-none">linux将访问80的流量重定向到9999端口sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 9999windows将本地80流量重定向到9999netsh interface portproxy add v4tov4 listenport&#x3D;80 listenaddress&#x3D;192.168.154.129 connectport&#x3D;9999 connectaddress&#x3D;192.168.154.129<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致过程如下：</p></li></ul><p><img src="..%5C..%5C..%5Ctypora-user-images%5Cimage-20240704171847360.png" alt="image-20240704171847360" /></p><p>实战中有一些http的web，就可以设置https的上线beacon，通过此方式进行中转上线。</p><p><strong>yy一句，理论上不单单可以根据协议区分，协议只是一个比较明显的特征，区分不同的数据包，在协议相同的情况下也可以做到端口复用，是理论上的思路，没找到现成的工具</strong></p><h2 id="0x02基于httpsys-winrm-端口复用"><a class="markdownIt-Anchor" href="#0x02基于httpsys-winrm-端口复用"></a> 0x02基于HTTP.sys + Winrm 端口复用</h2><p>首先明确概念</p><p>HTTP.sys是iis的驱动，iis中不同应用可以使用相同的端口，这也是其驱动的工作原理，可以根据注册的URL前缀，将请求分发到不同应用，也就实现了端口复用。（其实和反向代理差不多）</p><p>Winrm服务，这个我们在内网渗透中用的比较多，这个服务在2012及其以后的机器默认开放，他本质上就是在<strong>HTTP.sys上注册了wsman的URL前缀，默认监听端口5985</strong>，所以也能理解为什么winrm默认走的http协议。</p><p>所以这个复用也就很好理解了，<em>配置好winrm，就能在web服务连接winrm服务。</em></p><p>这个复用最终的效果就是使用winrm服务，winrm服务的特点我们搞内网多也知道横向移动可以使用该端口认证执行命令（此过程无文件落地）。</p><p>目前能想到的应用点：</p><ul><li>横向移动/后门</li><li>应对极端环境下的渗透测试任务（防火墙策略配置很死、强终端对抗，如：无法落地文件</li></ul><p>理解整个利用过程，这里的winrm服务我们也能理解是个代指，winrm是windows自带的，我们实战一样可以自实现调用这种http.sys驱动机制的API接口，最终实现一个类winrm服务做后门。（webshell等，又回到了上面的正向HTTP隧道）</p><p>大概就是：<a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/UsePipeToExeCmd.cpp">https://github.com/3gstudent/Homework-of-C-Language/blob/master/UsePipeToExeCmd.cpp</a></p><p>三好学生写的是命令执行，那理论上应该也可以做正向http隧道？但目前没找到现成的工具，后面实战用到再考虑。</p><h2 id="0x03基于socket绑定特性的端口复用"><a class="markdownIt-Anchor" href="#0x03基于socket绑定特性的端口复用"></a> 0x03基于socket绑定特性的端口复用</h2><p>我们知道，一般来说在我们启动一个新的端口，如果当前端口已被占用，就会出现以下错误。</p><pre class="line-numbers language-none"><code class="language-none">Error: listen tcp 127.0.0.1:8080: bind: Only one usage of each socket address (protocol&#x2F;network address&#x2F;port) is normally permitted.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在缺省条件下，一个套接口不能与一个已在使用中的本地地址捆绑（bind())）。但有时会需要“重用”地址。因为每一个连接都由本地地址和远端地址的组合唯一确定，所以只要远端地址不同，两个套接口与一个地址捆绑并无大碍。为了通知套接口实现不要因为一个地址已被一个套接口使用就不让它与另一个套接口捆绑。</p><p>然而，根据TCP/IP标准，端口本身是允许复用的。绑定端口的本质是，当系统接收到一个TCP报文段或UDP数据报时，可以根据其头部的端口字段找到对应的进程，并将数据传递给相应的进程。多个业务共用同一个端口的情况下其实很常见</p><p>在这个背景下，<code>SO_REUSEPORT</code> 和 <code>SO_REUSEADDR</code> 是两个套接字选项，它们允许在特定情况下重新使用端口：</p><ul><li><strong>SO_REUSEPORT：</strong> 允许多个套接字同时绑定到相同的地址和端口，可以同时接收传入的连接，适用于实现负载均衡或者多进程/线程同时监听同一端口的场景。</li><li><strong>SO_REUSEADDR：</strong> 允许在一个套接字使用过程中被终止后，其他套接字可以立即再次绑定到相同的地址和端口，有助于在服务器重启后快速恢复服务。</li></ul><p>我们在建立socket连接时，指定好这两个参数，就可以重新使用已经绑定的端口，完成端口复用了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> lc <span class="token operator">=</span> net<span class="token punctuation">.</span>ListenConfig<span class="token punctuation">&#123;</span>Control<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">,</span> c syscall<span class="token punctuation">.</span>RawConn<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> opErr <span class="token builtin">error</span><span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Control</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>fd <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>opErr <span class="token operator">=</span> windows<span class="token punctuation">.</span><span class="token function">SetsockoptInt</span><span class="token punctuation">(</span>windows<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">,</span> windows<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span> windows<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> opErr<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点：iis无法复用（iis5以下可以，可以考虑使用上面HTTP.sys的方法）、3389无法复用（RDP可以考虑采用隧道方式：<a href="https://github.com/nccgroup/SocksOverRDP%EF%BC%89">https://github.com/nccgroup/SocksOverRDP）</a></p><h3 id="socket复用技术缺点"><a class="markdownIt-Anchor" href="#socket复用技术缺点"></a> socket复用技术缺点</h3><p>理论很丰满，现实众是否真的这么简单呢？</p><p>我们设置socket的SO_REUSEADDR参数并不一定其作用</p><ul><li>程序编写人员 socket 在绑定前需要使用 setsockopt 指定 SO_EXCLUSIVEADDRUSE   要求独占所有的端口地址，而不允许复用。这样其它人就无法复用这个端口了，即使你设置了 socket 为 SO_REUSEADDR   也没有用，程序根本跑不起来。</li><li>iis无法复用</li></ul><p><img src="..%5C..%5C..%5Ctypora-user-images%5Cimage-20240715154737649.png" alt="image-20240715154737649" /></p><h2 id="0x04基于驱动的端口复用"><a class="markdownIt-Anchor" href="#0x04基于驱动的端口复用"></a> 0x04基于驱动的端口复用</h2><p>使用驱动程序进行端口复用和转发：</p><p><a href="https://github.com/Arno0x/DivertTCPconn">https://github.com/Arno0x/DivertTCPconn</a></p><p><a href="https://github.com/praetorian-inc/PortBender">https://github.com/praetorian-inc/PortBender</a></p><p>原理之后有精力再去分析</p><p>参考连接：</p><p><a href="https://uknowsec.cn/posts/notes/frsocks+protoplex+%E6%B5%81%E9%87%8F%E9%87%8D%E5%AE%9A%E5%90%91%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8.html%EF%BC%88frsocks+protoplex+%E6%B5%81%E9%87%8F%E9%87%8D%E5%AE%9A%E5%90%91%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%EF%BC%89">https://uknowsec.cn/posts/notes/frsocks+protoplex+流量重定向实现端口复用.html（frsocks+protoplex+流量重定向实现端口复用）</a></p><p><a href="https://paper.seebug.org/1004/%EF%BC%88%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%90%8E%E9%97%A8%EF%BC%89">https://paper.seebug.org/1004/（一条命令实现端口复用后门）</a></p><p><a href="https://3gstudent.github.io/%E5%88%A9%E7%94%A8IIS%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%88%E5%88%A9%E7%94%A8IIS%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%89">https://3gstudent.github.io/利用IIS的端口共享功能绕过防火墙（利用IIS的端口共享功能绕过防火墙）</a></p><p><a href="https://c1y2m3.github.io/2019/11/21/%E6%8E%A2%E7%B4%A2%E5%9F%BA%E4%BA%8EHTTP.SYS%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/%EF%BC%88%E6%8E%A2%E7%B4%A2%E5%9F%BA%E4%BA%8EHTTP.SYS%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%EF%BC%89">https://c1y2m3.github.io/2019/11/21/探索基于HTTP.SYS实现权限维持/（探索基于HTTP.SYS实现权限维持）</a></p><p><a href="https://github.com/p1d3er/port_reuse">https://github.com/p1d3er/port_reuse</a></p><p><a href="http://mobile.51cto.com/hot-557084.html">http://mobile.51cto.com/hot-557084.html</a> （聊聊端口复用的实现和坑点）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很多情况下遇到无法解析webshell环境（python之类的rce），或内网环境遇到强隔离，限定了通讯端口。&lt;/p&gt;
&lt;p&gt;端口复用工作中用的不算太多，主要是考虑客户业务的稳定性，导致很多时候不太敢上端口复用。&lt;/p&gt;
&lt;p&gt;端口复用根据不同场景有不同的实现方案，下面简单</summary>
      
    
    
    
    
    <category term="端口复用" scheme="https://cyxsec.github.io/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>不出网C2上线</title>
    <link href="https://cyxsec.github.io/2022/07/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8/"/>
    <id>https://cyxsec.github.io/2022/07/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8/</id>
    <published>2022-07-05T03:16:57.000Z</published>
    <updated>2024-07-15T09:52:28.096Z</updated>
    
    <content type="html"><![CDATA[<p>先简单带一下常见的正向HTTP隧道</p><h2 id="0x01正向http隧道"><a class="markdownIt-Anchor" href="#0x01正向http隧道"></a> 0x01正向HTTP隧道</h2><p>这种方式应用范围很广，有webshell的情况下都支持此方式</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>页面上存在成熟的工具Reg、NeoReg、suo5等</p><p>原理大概如下图所示：（这里直接拿Viper作者的图来说了）</p><p><img src="..%5C..%5C..%5Ctypora-user-images%5Cimage-20240709180051975.png" alt="image-20240709180051975" /></p><ul><li><p>client运行在互联网的vps上，开启端口监听处理proxychains转发的tcp连接。（client对应的就是reg的本地python脚本和suo5的客户端）</p></li><li><p>clinet从tcp连接中读取数据，将数据存储在post请求中发送到webshell。</p></li><li><p>webshell将http请求解析并进行转发。（webshell集成了上图中的server)</p></li></ul><p>suo5其实实现了基本全双工的模式，这个问题后面有空再研究。</p><h2 id="0x02不出网上线cs场景"><a class="markdownIt-Anchor" href="#0x02不出网上线cs场景"></a> 0x02不出网上线CS场景</h2><p>CS的beacon只能反向连接，不出网的情况下无法直接反向连接外网vps</p><p>其实也可以利用中转的方式进行上线</p><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><p>成熟的工具：pystinger（毒刺）</p><p>原理大概如下图所示：（这里直接拿Viper作者的图来说了）</p><p><img src="..%5C..%5C..%5Ctypora-user-images%5Cimage-20240709180109508.png" alt="image-20240709180109508" /></p><p>server端：</p><ul><li>beacon将http请求(假设数据为AAAAAA)发送到server。</li><li>server将(AAAAAA)存储到缓存，并保持与beacon的http连接。</li></ul><p>client端：</p><ul><li>请求webshell。</li><li>webshell转发请求到server。</li><li>server将缓存的(AAAAA)填充到http应答中。</li><li>webshell将server的应答转发给client。</li><li>client从应答中获取数据(AAAAA)。</li><li>client与cobaltstike的listener建立tcp连接。</li><li>client发送(AAAAA)到cobaltstrike的listener。</li><li>conbaltstrike发送应答数据(BBBBBB)。</li><li>client将数据(BBBBB)封装到http请求中,通过webshell转发到server。</li><li>server通过之前保持的http连接将(BBBBBB)发送到beacon。</li></ul><p>实际的流程就是数据包的转换和转发，理解完上面的正向，反向的逻辑只是增加了一个监听而已。</p><p>可能会有人有这样的问题：<strong>这里的webshell可以类似reg把server也整合一下吗，不落地server？</strong></p><p>答案是不行的，区别于正向连接，反向连接时需要监听端口，webshell是无法做到的，所以使用毒刺的时候，不出网的机器需要落地两个文件（webshell、server）</p><h2 id="0x03实战钓鱼不出网上线"><a class="markdownIt-Anchor" href="#0x03实战钓鱼不出网上线"></a> 0x03实战钓鱼不出网上线</h2><p>根据上面的不出网上线cs案例解释，其实主要做的就是流量转发和格式化</p><p>格式化的部分就是毒刺的client和server在做，但是这样会在webshell的机器上落地sever的二进制文件，同时需要开启监听，不够opsec。</p><p>不妨把思路发散一下：有没有可能把server和c2马绑在一起呢？或者换句话说，我们可以重新写我们的c2马，直接把结果写入到webshell缓存中，c2的控制端会请求webshell获取缓存读取结果，就完成了不出网的上线流程。</p><p>这个案例其实之前项目遇见过：</p><p><strong>钓鱼的时候，机器不出网如何上线？？</strong></p><p>找内外网可能互通的业务：邮件系统、OA系统等（可能需要账号，但是这些系统大概率内外网是互通的），或者直接摆烂，找能做数据交互的系统域名，批量都试一下。</p><p>对应我们上面的思路，重新设计我们的c2马和服务端，或者没那么麻烦，自己写一个能执行命令、文件上传和读取的马就可以了。</p><p>木马：</p><ul><li><p>定时读取邮件、OA系统或者其他能存储数据的系统的数据。（如邮件内容，系统编辑内容、oa聊天记录等等），作为命令输入。</p></li><li><p>获取命令输入后将执行结果写入对应系统。</p></li></ul><p>因为内外网系统互通</p><p>c2控制端：</p><ul><li>将想执行的命令写入到外网系统，供木马读取</li><li>将木马执行结果读取并响应</li></ul><p>实战应用的话，其实还是可以用的。</p><p>机器不出网的话，肯定会配内部dns，所以去外网找可以存储数据的系统域名，写木马的时候加上批量的逻辑if else尝试所有可能的域名，保证稳定获取结果就可以了。</p><p>参考连接：</p><p><a href="https://mp.weixin.qq.com/s/WzXztQoiqBec-y23dRj0ww%EF%BC%88%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%AE%9E%E8%B7%B5%EF%BC%9A%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E6%96%B0%E6%80%9D%E8%B7%AF%EF%BC%89">https://mp.weixin.qq.com/s/WzXztQoiqBec-y23dRj0ww（红队攻防实践：不出网主机搭建内网隧道新思路）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先简单带一下常见的正向HTTP隧道&lt;/p&gt;
&lt;h2 id=&quot;0x01正向http隧道&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x01正向http隧道&quot;&gt;&lt;/a&gt; 0x01正向HTTP隧道&lt;/h2&gt;
&lt;p&gt;这种方式应用范围很广，有websh</summary>
      
    
    
    
    
    <category term="不出网利用" scheme="https://cyxsec.github.io/tags/%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
</feed>
